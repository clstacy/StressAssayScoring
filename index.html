<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Stress Assay Tools</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }
    #tabs {
      display: flex;
      background-color: #333;
    }
    #tabs button {
      flex: 1;
      padding: 14px 16px;
      background-color: inherit;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 17px;
    }
    #tabs button:hover {
      background-color: #575757;
    }
    #tabs button.active {
      background-color: #575757;
    }
    .tabContent {
      display: none;
      padding: 20px;
    }
    /* Additional styles for the apps */
    #container {
      display: flex;
    }
    #sidebar {
      width: 300px;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      background-color: #f9f9f9;
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
    }
    #sidebarContent {
      flex-grow: 1;
      overflow-y: auto;
      padding: 20px;
    }
    #sidebarFooter {
      padding: 20px;
      border-top: 1px solid #ccc;
    }
    #mainContent {
      margin-left: 300px;
      flex-grow: 1;
      padding: 20px;
      overflow-y: auto;
      box-sizing: border-box;
      height: 100vh;
    }
    #imageGrid {
      display: flex;
      flex-wrap: wrap;
    }
    .imageItem {
      position: relative;
      margin: 5px;
      padding: 5px;
      border: 1px solid #ddd;
    }
    .imageItem img {
      width: 150px;
      height: auto;
      border: 3px solid black;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    .imageItem .scoreOverlay {
      position: absolute;
      bottom: 5px;
      left: 5px;
      background-color: rgba(255, 255, 255, 0.7);
      padding: 2px 5px;
      font-size: 14px;
      z-index: 10;
    }
    #paginationControls {
      margin-top: 10px;
      text-align: center;
    }
    #paginationControls button {
      margin: 0 5px;
    }
    #loadingMessage {
      font-size: 18px;
      color: green;
    }
    #progressBar {
      width: 100%;
      background-color: #ddd;
      display: none;
    }
    #progressBar div {
      width: 0%;
      height: 20px;
      background-color: #4caf50;
      text-align: center;
      line-height: 20px;
      color: white;
    }
    /* Styles for Image Grid Cropper */
    #uploadSection {
      margin-bottom: 20px;
    }
    #progress {
      margin-top: 10px;
    }
    #imageContainer {
      margin-top: 20px;
    }
    #imageContainer img {
      max-width: 100%;
    }
    #downloadButton {
      margin-top: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
    }
    input[type="text"], input[type="number"], textarea {
      width: 100%;
      padding: 5px;
      margin-bottom: 10px;
      box-sizing: border-box;
    }
  </style>
</head>
<body>

  <div id="tabs">
    <button class="tablink" onclick="openTab(event, 'ImageCropper')">Image Grid Cropper</button>
    <button class="tablink active" onclick="openTab(event, 'ScoringApp')">Stress Assay Scoring App</button>
  </div>

  <div id="ScoringApp" class="tabContent" style="display: block;">
    <!-- Stress Assay Scoring App Code -->
    <div id="container">
      <div id="sidebar">
        <div id="sidebarContent">
          <h1>Stress Assay Scoring App</h1>
          <div id="instructions">
            <h2>Instructions</h2>
            <ol>
              <li>Upload a folder containing your images.</li>
              <li>Set custom scores if desired, or use default scoring system.</li>
              <li>Set the replication factor (e.g., 1.5 for 50% additional replicates).</li>
              <li>Click "Load Images" to begin.</li>
              <li>Select a score and click on images to assign or change scores.</li>
              <li>Go to next page to score replicates.</li>
              <li>When finished, click "Download Scores" to export the data.</li>
            </ol>
          </div>
          <label for="fileInput">Upload Images (Folder or Files):</label>
          <input type="file" id="fileInput" accept=".jpg,.jpeg,.png,.tiff,.tif" webkitdirectory multiple>
          <br><br>
          <label for="scorerName">Scorer Name:</label>
          <input type="text" id="scorerName" placeholder="Enter scorer's name">
          <br><br>
          <label for="customScores">Enter Custom Scores (comma-separated, optionally with labels using colon):</label>
          <input type="text" id="customScores" placeholder="e.g., 0: Poor,1: Fair,2: Good">
          <button id="setScores">Set Scores</button>
          <br><br>
          <label for="replicationFactor">Replication Factor (e.g., 1.5):</label>
          <input type="number" id="replicationFactor" value="2" min="1" step="0.1">
          <br><br>
          <button id="loadImages">Load Images</button>
          <br><br>
          <div id="loadingMessage"></div>
          <div id="progressBar"><div></div></div>
        </div>
        <div id="sidebarFooter">
          <label for="scoreSelector">Select Score:</label>
          <select id="scoreSelector"></select>
          <button id="downloadScores">Download Scores</button>
          <br><br>
        </div>
      </div>
      <div id="mainContent">
        <div id="paginationControls" style="display: none;">
          <button id="prevPage">Previous</button>
          <span id="pageInfo"></span>
          <button id="nextPage">Next</button>
        </div>
        <hr>
        <div id="imageGrid"></div>
      </div>
    </div>
  </div>

  <div id="ImageCropper" class="tabContent">
    <!-- Image Grid Cropper Code -->
    <h1>Image Dicer</h1>
    <div id="uploadSection">
      <label for="imageFiles">Upload Images:</label>
      <input type="file" id="imageFiles" accept="image/*" multiple>
      <label for="rows">Number of Rows:</label>
      <input type="number" id="rows" value="5" min="1">
      <label for="cols">Number of Columns:</label>
      <input type="number" id="cols" value="12" min="1">
      <label for="rowLabels">Row Labels (comma-separated):</label>
      <textarea id="rowLabels">Mock,0.4M.NaCl,5pctEtOH,0.4mMH2O2,37cHeat</textarea>
      <label for="colLabels">Column Labels (comma-separated):</label>
      <textarea id="colLabels">0mMH2O2,0.75mMH2O2,1mMH2O2,1.25mMH2O2,1.5mMH2O2,1.75mMH2O2,2mMH2O2,2.5mMH2O2,3mMH2O2,3.5mMH2O2,4mMH2O2,5mMH2O2</textarea>
      <button id="processButton">Process Images</button>
      <div id="progress"></div>
    </div>
    <div id="imageContainer"></div>
    <button id="downloadButton" style="display: none;">Download Cropped Images</button>
  </div>

  <!-- Include JSZip and FileSaver.js libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <script>
    // Tab functionality
    function openTab(evt, tabName) {
      var i, tabContent, tablinks;
      tabContent = document.getElementsByClassName("tabContent");
      for (i = 0; i < tabContent.length; i++) {
        tabContent[i].style.display = "none";
      }
      tablinks = document.getElementsByClassName("tablink");
      for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
      }
      document.getElementById(tabName).style.display = "block";
      evt.currentTarget.className += " active";
    }

    // Stress Assay Scoring code
    let images = [];
    let scores = {};
    let scoreLabels = {};
    let currentPage = 1;
    let totalPages = 1;
    let scoreColors = {};
    let replicationFactor = 1;

    document.addEventListener('DOMContentLoaded', () => {
      setDefaultScores();
    });

    function setDefaultScores() {
      const defaultScoresArray = ['0', '1', '2', '3', '4'];
      scoreLabels = {
        '0': '0 (0-2 colonies)',         
        '1': '1 (3-10 colonies)',         
        '2': '2 (>11, countable)',         
        '3': '3 (TNTC, no Confluence)',         
        '4': '4 (TNTC, Confluent)'
      };
      assignScoreColors(defaultScoresArray);
      populateScoreSelector(defaultScoresArray);
    }

    document.getElementById('fileInput').addEventListener('change', function(event) {
      const files = event.target.files;
      if (files.length > 0) {
        document.getElementById('loadingMessage').textContent = 'Ready to load images.';
      }
    });

    document.getElementById('setScores').addEventListener('click', () => {
      const customScoresInput = document.getElementById('customScores').value.trim();
      if (customScoresInput === '') {
        setDefaultScores();
      } else {
        const customScoresArray = parseCustomScores(customScoresInput);
        if (customScoresArray.length === 0) {
          alert('Please enter valid scores.');
          return;
        }
        assignScoreColors(customScoresArray);
        populateScoreSelector(customScoresArray);
      }
    });

    document.getElementById('loadImages').addEventListener('click', async () => {
      const fileInput = document.getElementById('fileInput');
      const files = fileInput.files;
      const scorerName = document.getElementById('scorerName').value;
      if (!scorerName) {
        alert('Please enter the scorer\'s name.');
        return;
      }
      if (files.length === 0) {
        alert('Please upload images.');
        return;
      }

      document.getElementById('loadingMessage').textContent = 'Loading and processing images...';
      document.getElementById('progressBar').style.display = 'block';

      images = [];
      scores = {};
      const validExtensions = ['jpg', 'jpeg', 'png', 'tiff', 'tif'];
      const totalFiles = files.length;
      let processedFiles = 0;

      for (const file of files) {
        const fileExtension = file.name.split('.').pop().toLowerCase();
        if (!validExtensions.includes(fileExtension)) {
          console.warn(`${file.name} is not a supported image file.`);
          updateProgress(++processedFiles, totalFiles);
          continue;
        }

        try {
          const imgData = await readFileAsync(file);
          let imageData = imgData;

          // If the image is a TIFF, convert it to JPEG
          if (fileExtension === 'tiff' || fileExtension === 'tif') {
            imageData = await convertTiffToJpeg(imgData);
          }

          images.push({
            name: file.name,
            data: imageData,
            isReplicate: false,
            originalName: file.name,
            rotation: getRandomRotation(),
            replicateNumber: 1
          });
        } catch (error) {
          console.error(`Error loading image ${file.name}:`, error);
        }

        updateProgress(++processedFiles, totalFiles);
      }

      if (images.length === 0) {
        alert('No valid images found.');
        document.getElementById('loadingMessage').textContent = '';
        document.getElementById('progressBar').style.display = 'none';
        return;
      }

      replicationFactor = parseFloat(document.getElementById('replicationFactor').value) || 1;
      images = replicateImages(images, replicationFactor);

      shuffleArray(images);

      currentPage = 1;
      totalPages = Math.ceil(replicationFactor);

      sortImages();
      displayImages();

      document.getElementById('loadingMessage').textContent = '';
      document.getElementById('progressBar').style.display = 'none';
    });

    function updateProgress(processed, total) {
      const progressBar = document.getElementById('progressBar').children[0];
      const percentage = Math.round((processed / total) * 100);
      progressBar.style.width = percentage + '%';
      progressBar.textContent = percentage + '%';
    }

    function readFileAsync(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(event) {
          resolve(event.target.result);
        };
        reader.onerror = function(error) {
          reject(error);
        };
        reader.readAsDataURL(file);
      });
    }

    async function convertTiffToJpeg(dataUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          // Resize the canvas to match the image
          canvas.width = img.width;
          canvas.height = img.height;

          // Draw the image onto the canvas
          ctx.drawImage(img, 0, 0);

          // Convert the canvas to a compressed JPEG image
          const compressedImage = canvas.toDataURL('image/jpeg', 0.2); // Adjust quality as needed
          resolve(compressedImage);
        };
        img.onerror = function(error) {
          reject(error);
        };
        img.src = dataUrl;
      });
    }

    function parseCustomScores(input) {
      const scores = input.split(',').map(s => s.trim()).filter(s => s !== '');
      const uniqueScores = [];
      scoreLabels = {};

      scores.forEach(s => {
        const [score, label] = s.split(':').map(part => part.trim());
        if (score && !uniqueScores.includes(score)) {
          uniqueScores.push(score);
          scoreLabels[score] = label || score;
        }
      });

      return uniqueScores;
    }

    function assignScoreColors(scoresArray) {
      const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'teal', 'magenta'];
      scoreColors = {};
      scoresArray.forEach((score, index) => {
        scoreColors[score] = colors[index % colors.length];
      });
    }

    function populateScoreSelector(scoresArray) {
      const scoreSelector = document.getElementById('scoreSelector');
      scoreSelector.innerHTML = '';
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = '-- Select Score --';
      scoreSelector.appendChild(defaultOption);

      scoresArray.forEach(score => {
        const option = document.createElement('option');
        option.value = score;
        option.textContent = scoreLabels[score] || score;
        scoreSelector.appendChild(option);
      });
    }

    function replicateImages(imagesArray, replicationFactor) {
      const replicatedImages = [];
      const totalReps = Math.floor(replicationFactor);
      const extraRepFraction = replicationFactor - totalReps;

      // Replicate images for the integer part of replication factor
      for (let i = 1; i <= totalReps; i++) {
        imagesArray.forEach(image => {
          const replicatedImage = {
            ...image,
            isReplicate: i > 1,
            name: i === 1 ? image.originalName : `${image.originalName}_replicate_${i - 1}`,
            rotation: getRandomRotation(),
            replicateNumber: i
          };
          replicatedImages.push(replicatedImage);
        });
      }

      // Handle fractional replication
      if (extraRepFraction > 0) {
        const numExtraReps = Math.round(imagesArray.length * extraRepFraction);
        const shuffledImages = [...imagesArray];
        shuffleArray(shuffledImages);
        const selectedImages = shuffledImages.slice(0, numExtraReps);

        selectedImages.forEach(image => {
          const replicatedImage = {
            ...image,
            isReplicate: true,
            name: `${image.originalName}_replicate_${totalReps}`,
            rotation: getRandomRotation(),
            replicateNumber: totalReps + 1
          };
          replicatedImages.push(replicatedImage);
        });

        totalPages += 1;
      }

      return replicatedImages;
    }

    function getRandomRotation() {
      return Math.random() < 0.5 ? 0 : 180;
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function sortImages() {
      images.sort((a, b) => {
        const aScored = scores[a.name] ? 1 : 0;
        const bScored = scores[b.name] ? 1 : 0;

        if (aScored !== bScored) {
          return aScored - bScored; // Unscored images first
        } else if (aScored === 1 && bScored === 1) {
          // Both images are scored, sort by numeric score ascending
          const aScore = parseFloat(scores[a.name].score);
          const bScore = parseFloat(scores[b.name].score);
          return aScore - bScore;
        } else {
          return 0; // Keep current order
        }
      });
    }

    function displayImages() {
      const grid = document.getElementById('imageGrid');
      grid.innerHTML = '';

      const imagesToDisplay = images.filter(img => img.replicateNumber === currentPage);

      imagesToDisplay.forEach((img, index) => {
        const imgContainer = document.createElement('div');
        imgContainer.classList.add('imageItem');

        const imgElement = document.createElement('img');
        imgElement.src = img.data;
        imgElement.dataset.index = index;
        imgElement.style.transform = `rotate(${img.rotation}deg)`;
        imgElement.addEventListener('click', () => {
          const scoreSelector = document.getElementById('scoreSelector');
          if (scoreSelector.value === '') {
            alert('Please select a score.');
            return;
          }
          const score = scoreSelector.value;
          const scoreText = scoreLabels[score];
          const timestamp = new Date().toISOString();
          scores[img.name] = {
            score: score,
            scoreDescription: scoreText,
            timestamp: timestamp,
            isReplicate: img.isReplicate || false,
            originalName: img.originalName
          };
          imgElement.style.borderColor = scoreColors[score] || 'red';

          if (!imgContainer.querySelector('.scoreOverlay')) {
            const overlay = document.createElement('div');
            overlay.classList.add('scoreOverlay');
            overlay.textContent = 'Score: ' + scoreText;
            imgContainer.appendChild(overlay);
          } else {
            imgContainer.querySelector('.scoreOverlay').textContent = 'Score: ' + scoreText;
          }

          sortImages();
          displayImages();
        });

        if (scores[img.name]) {
          const assignedScore = scores[img.name].score;
          imgElement.style.borderColor = scoreColors[assignedScore] || 'red';
          const overlay = document.createElement('div');
          overlay.classList.add('scoreOverlay');
          overlay.textContent = 'Score: ' + scoreLabels[assignedScore];
          imgContainer.appendChild(overlay);
        }

        imgContainer.appendChild(imgElement);
        grid.appendChild(imgContainer);
      });

      updatePaginationControls();
    }

    function updatePaginationControls() {
      const paginationControls = document.getElementById('paginationControls');
      paginationControls.style.display = 'block';
      document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages}`;

      document.getElementById('prevPage').disabled = currentPage === 1;
      document.getElementById('nextPage').disabled = currentPage === totalPages;
    }

    document.getElementById('prevPage').addEventListener('click', () => {
      if (currentPage > 1) {
        currentPage--;
        sortImages();
        displayImages();
      }
    });

    document.getElementById('nextPage').addEventListener('click', () => {
      if (currentPage < totalPages) {
        currentPage++;
        sortImages();
        displayImages();
      }
    });

    function getScoreLabel(score) {
      return scoreLabels[score] || score;
    }

    document.getElementById('downloadScores').addEventListener('click', () => {
      const scorerName = document.getElementById('scorerName').value;

      const unscoredImages = images.filter(img => !scores[img.name]);
      if (unscoredImages.length > 0) {
        const proceed = confirm(`There are ${unscoredImages.length} unscored images. Do you want to proceed?`);
        if (!proceed) return;
      }

      const unscoredReplicates = images.filter(img => img.isReplicate && !scores[img.name]);
      if (unscoredReplicates.length > 0) {
        alert(`Warning: Not all replicates have been scored.`);
      }

      const inconsistencies = checkConsistency();

      if (inconsistencies.length > 0) {
        alert(`There are ${inconsistencies.length} inconsistencies in replicated scores.`);
      }

      let csvContent = "Scorer Name,File Name,Numeric Score,Score Description,Timestamp,Replicate #,Original File Name\n";
      images.sort((a, b) => a.originalName.localeCompare(b.originalName));
      images.forEach(img => {
        const data = scores[img.name];
        const numericScore = data ? data.score : '';
        const scoreDescription = data ? data.scoreDescription : '';
        const timestamp = data ? data.timestamp : '';
        const replicateNum = img.replicateNumber;
        const originalFileName = img.originalName;
        csvContent += `"${scorerName}","${img.name}","${numericScore}","${scoreDescription}","${timestamp}","${replicateNum}","${originalFileName}"\n`;
      });

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      saveAs(blob, 'image_scores.csv');
    });

    function checkConsistency() {
      const inconsistencies = [];
      const scoreMap = {};

      images.forEach(img => {
        if (!scores[img.name]) return;
        const key = img.originalName;
        if (!scoreMap[key]) {
          scoreMap[key] = scores[img.name].score;
        } else {
          if (scoreMap[key] !== scores[img.name].score) {
            inconsistencies.push({
              originalFileName: img.originalName,
              replicateFileName: img.name,
              originalScore: getScoreLabel(scoreMap[key]),
              replicateScore: getScoreLabel(scores[img.name].score)
            });
          }
        }
      });
      return inconsistencies;
    }

    // Image Grid Cropper JavaScript code
    const processButton = document.getElementById('processButton');
    const imageFilesInput = document.getElementById('imageFiles');
    const rowsInput = document.getElementById('rows');
    const colsInput = document.getElementById('cols');
    const rowLabelsInput = document.getElementById('rowLabels');
    const colLabelsInput = document.getElementById('colLabels');
    const progressDiv = document.getElementById('progress');
    const imageContainer = document.getElementById('imageContainer');
    const downloadButton = document.getElementById('downloadButton');

    let croppedImagesZip;

    processButton.addEventListener('click', () => {
      const files = imageFilesInput.files;
      if (files.length === 0) {
        alert('Please upload at least one image.');
        return;
      }

      const rows = parseInt(rowsInput.value);
      const cols = parseInt(colsInput.value);
      if (isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) {
        alert('Please enter valid numbers for rows and columns.');
        return;
      }

      const rowLabels = rowLabelsInput.value.split(',').map(label => label.trim());
      const colLabels = colLabelsInput.value.split(',').map(label => label.trim());

      if (rowLabels.length !== rows) {
        alert(`Number of row labels (${rowLabels.length}) does not match number of rows (${rows}).`);
        return;
      }

      if (colLabels.length !== cols) {
        alert(`Number of column labels (${colLabels.length}) does not match number of columns (${cols}).`);
        return;
      }

      progressDiv.textContent = 'Processing images...';
      imageContainer.innerHTML = '';
      downloadButton.style.display = 'none';
      croppedImagesZip = new JSZip();

      let processedCount = 0;

      Array.from(files).forEach(file => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            processImage(img, file.name, rows, cols, rowLabels, colLabels);
            processedCount++;
            if (processedCount === files.length) {
              progressDiv.textContent = 'All images processed.';
              downloadButton.style.display = 'inline-block';
            } else {
              progressDiv.textContent = `Processed ${processedCount}/${files.length} images...`;
            }
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    });

    function processImage(img, fileName, rows, cols, rowLabels, colLabels) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      const cellWidth = Math.floor(img.width / cols);
      const cellHeight = Math.floor(img.height / rows);

      const baseFileName = fileName.substring(0, fileName.lastIndexOf('.')) || fileName;

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const x = j * cellWidth;
          const y = i * cellHeight;
          const width = cellWidth;
          const height = cellHeight;

          const cellCanvas = document.createElement('canvas');
          const cellCtx = cellCanvas.getContext('2d');
          cellCanvas.width = width;
          cellCanvas.height = height;

          cellCtx.drawImage(canvas, x, y, width, height, 0, 0, width, height);

          const cellDataURL = cellCanvas.toDataURL('image/jpeg');

          const rowLabel = rowLabels[i];
          const colLabel = colLabels[j];
          const croppedFileName = `${baseFileName}_${rowLabel}_${colLabel}.jpg`;

          // Add to ZIP
          const imgData = cellDataURL.split(',')[1]; // Remove the data:image/jpeg;base64, part
          croppedImagesZip.file(`${baseFileName}/${croppedFileName}`, imgData, { base64: true });

          // Optionally display the cropped image on the page
          // Comment the lines below to not display the images
          const cellImg = new Image();
          cellImg.src = cellDataURL;
          cellImg.style.margin = '5px';
          cellImg.style.border = '1px solid #ddd';
          imageContainer.appendChild(cellImg);
        }
      }
    }

    downloadButton.addEventListener('click', () => {
      progressDiv.textContent = 'Generating ZIP file...';
      croppedImagesZip.generateAsync({ type: 'blob' }).then(function(content) {
        saveAs(content, 'cropped_images.zip');
        progressDiv.textContent = 'Download complete.';
      });
    });
  </script>
</body>
</html>
