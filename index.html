<!DOCTYPE html>
<html>
<head>
  <title>Stress Assay Scoring App</title>
  <style>
    /* CSS styles */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
    }

    #container {
      display: flex;
    }

    #sidebar {
      width: 300px;
      padding: 20px;
      box-sizing: border-box;
      background-color: #f9f9f9;
      overflow-y: auto;
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
    }

    #mainContent {
      margin-left: 300px; /* same as sidebar width */
      padding: 20px;
      overflow-y: auto;
      height: 100vh;
      box-sizing: border-box;
    }

    #imageGrid {
      display: flex;
      flex-wrap: wrap;
    }

    .imageItem {
      position: relative;
      margin: 5px;
    }

    .imageItem img {
      width: 150px;
      height: auto;
      border: 3px solid black;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .imageItem .scoreOverlay {
      position: absolute;
      bottom: 5px;
      left: 5px;
      background-color: rgba(255, 255, 255, 0.7);
      padding: 2px 5px;
      font-size: 14px;
      z-index: 10;
    }

    #paginationControls {
      margin-top: 10px;
      text-align: center;
    }

    #paginationControls button {
      margin: 0 5px;
    }

    #loadingMessage {
      font-size: 18px;
      color: green;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <h1>Stress Assay Scoring App</h1>

      <div id="instructions">
        <h2>Instructions</h2>
        <ol>
          <li>Upload a ZIP file containing your images.</li>
          <li>Set custom scores if desired, or use default scores by clicking "Set Scores" without entering any scores.</li>
          <li>Set the replication factor if needed (e.g., 1.2 for 20% replication).</li>
          <li>Choose whether to enable pagination and specify images per page.</li>
          <li>Click "Load Images" to begin.</li>
          <li>Select a score and click on images to assign or change scores.</li>
          <li>Use pagination controls to navigate through images (if enabled).</li>
          <li>Once finished, click "Download Scores" to export the data.</li>
        </ol>
      </div>

      <input type="file" id="zipInput" accept=".zip">
      <br><br>

      <label for="customScores">Enter Custom Scores (comma-separated, optionally with labels using colon):</label>
      <input type="text" id="customScores" placeholder="e.g., 0: 0-Poor,1: 1-Fair,2: 2-Good">
      <button id="setScores">Set Scores</button>
      <br><br>

      <label for="replicationFactor">Replication Factor (e.g., 1.2 for 20% replication):</label>
      <input type="number" id="replicationFactor" value="2.0" min="1.0" step="0.1">
      <br><br>

      <input type="checkbox" id="enablePagination">
      <label for="enablePagination">Enable Pagination</label>
      <br><br>

      <div id="paginationSettings" style="display: none;">
        <label for="imagesPerPage">Images Per Page:</label>
        <input type="number" id="imagesPerPage" value="20" min="1" step="1">
        <br><br>
      </div>

      <button id="loadImages">Load Images</button>
      <br><br>

      <label for="scoreSelector">Select Score:</label>
      <select id="scoreSelector"></select>
      <button id="downloadScores">Download Scores</button>
      <br><br>

      <div id="loadingMessage"></div>
    </div>

    <div id="mainContent">
      <div id="paginationControls" style="display: none;">
        <button id="prevPage">Previous</button>
        <span id="pageInfo"></span>
        <button id="nextPage">Next</button>
      </div>
      <hr>
      <div id="imageGrid"></div>
    </div>
  </div>

  <!-- Include fflate and FileSaver.js -->
  <script src="https://cdn.jsdelivr.net/npm/fflate@0.7.3/umd/index.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <!-- Main JavaScript code -->
  <script>
    // Variables to store images and scores
    let images = [];
    let scores = {};
    let scoreLabels = {};
    let currentPage = 1;
    let imagesPerPage = 20;
    let paginationEnabled = false;
    let scoreColors = {}; // To store colors for each score

    // On page load, set default scores
    document.addEventListener('DOMContentLoaded', () => {
      setDefaultScores();
    });

    // Function to set default scores
    function setDefaultScores() {
      const defaultScoresArray = ['0', '1', '2', '3', '4'];
      scoreLabels = {
        '0': '0 - (0-2 colonies)',
        '1': '1 - (3-10 colonies)',
        '2': '2 - (>11, countable)',
        '3': '3 - (TNTC, no Confluence)',
        '4': '4 - (TNTC, Confluent)'
      };
      assignScoreColors(defaultScoresArray);
      populateScoreSelector(defaultScoresArray);
    }

    // Handle zip file upload
    document.getElementById('zipInput').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file) {
        document.getElementById('loadingMessage').textContent = 'Ready to load images.';
      }
    });

    // Event listener for setting custom scores
    document.getElementById('setScores').addEventListener('click', () => {
      const customScoresInput = document.getElementById('customScores').value.trim();
      let customScoresArray;

      if (customScoresInput === '') {
        // Use default scores
        setDefaultScores();
      } else {
        customScoresArray = parseCustomScores(customScoresInput);
        if (customScoresArray.length === 0) {
          alert('Please enter valid scores.');
          return;
        }
        assignScoreColors(customScoresArray);
        populateScoreSelector(customScoresArray);
      }
    });

    // Show or hide pagination settings
    document.getElementById('enablePagination').addEventListener('change', function() {
      const paginationSettings = document.getElementById('paginationSettings');
      if (this.checked) {
        paginationSettings.style.display = 'block';
      } else {
        paginationSettings.style.display = 'none';
      }
    });

    // Event listener for loading images
    document.getElementById('loadImages').addEventListener('click', () => {
      const fileInput = document.getElementById('zipInput');
      const file = fileInput.files[0];
      if (!file) {
        alert('Please upload a zip file containing images.');
        return;
      }

      document.getElementById('loadingMessage').textContent = 'Unzipping and processing images...';

      images = []; // Reset images array
      scores = {}; // Reset scores

      const reader = new FileReader();
      reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const unzippedFiles = fflate.unzipSync(data);
        processUnzippedFiles(unzippedFiles);
      };
      reader.readAsArrayBuffer(file);
    });

    function processUnzippedFiles(files) {
      for (const [filename, fileData] of Object.entries(files)) {
        if (/\.(png|jpg|jpeg)$/i.test(filename)) {
          const blob = new Blob([fileData], { type: 'image/jpeg' });
          const imgUrl = URL.createObjectURL(blob);
          images.push({
            name: filename,
            data: imgUrl,
            isReplicate: false,
            originalName: filename,
            rotation: getRandomRotation()
          });
        }
      }

      if (images.length === 0) {
        alert('No valid images found in the zip file.');
        document.getElementById('loadingMessage').textContent = '';
        return;
      }

      // Replicate images if needed
      const replicationFactor = parseFloat(document.getElementById('replicationFactor').value) || 1.0;
      images = replicateImages(images, replicationFactor);

      // Shuffle images
      shuffleArray(images);

      // Pagination settings
      paginationEnabled = document.getElementById('enablePagination').checked;
      imagesPerPage = parseInt(document.getElementById('imagesPerPage').value) || 20;
      currentPage = 1;

      // Display images
      sortImages();
      displayImages();

      document.getElementById('loadingMessage').textContent = '';
    }

    // Function to parse custom scores input
    function parseCustomScores(input) {
      const scores = input.split(',').map(s => s.trim()).filter(s => s !== '');
      const uniqueScores = [];
      scoreLabels = {};

      scores.forEach(s => {
        const [score, label] = s.split(':').map(part => part.trim());
        if (score && !uniqueScores.includes(score)) {
          uniqueScores.push(score);
          scoreLabels[score] = label || score; // Use label if provided, else use score as label
        }
      });

      return uniqueScores;
    }

    // Function to assign colors to scores
    function assignScoreColors(scoresArray) {
      const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'teal', 'magenta'];
      scoreColors = {};
      scoresArray.forEach((score, index) => {
        scoreColors[score] = colors[index % colors.length];
      });
    }

    // Function to populate the score selector
    function populateScoreSelector(scoresArray) {
      const scoreSelector = document.getElementById('scoreSelector');
      scoreSelector.innerHTML = ''; // Clear existing options
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = '-- Select Score --';
      scoreSelector.appendChild(defaultOption);

      scoresArray.forEach(score => {
        const option = document.createElement('option');
        option.value = score;
        option.textContent = scoreLabels[score] || score;
        scoreSelector.appendChild(option);
      });
    }

    // Function to replicate images
    function replicateImages(imagesArray, replicationFactor) {
      const numOriginalImages = imagesArray.length;
      const numReplicates = Math.round((replicationFactor - 1) * numOriginalImages);

      const replicatedImages = [];
      for (let i = 0; i < numReplicates; i++) {
        const randomIndex = Math.floor(Math.random() * numOriginalImages);
        const originalImage = imagesArray[randomIndex];

        // Create a copy of the image object with a unique name
        const replicatedImage = {
          ...originalImage,
          isReplicate: true,
          name: originalImage.name + '_replicate_' + (i + 1),
          rotation: getRandomRotation()
        };

        replicatedImages.push(replicatedImage);
      }

      // Combine original and replicated images
      return imagesArray.concat(replicatedImages);
    }

    // Function to get a random rotation angle (0 or 180 degrees)
    function getRandomRotation() {
      return Math.random() < 0.5 ? 0 : 180;
    }

    // Function to shuffle an array
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Function to sort images based on score
    function sortImages() {
      images.sort((a, b) => {
        const scoreA = scores[a.name] ? scores[a.name].score : null;
        const scoreB = scores[b.name] ? scores[b.name].score : null;

        if (scoreA === null && scoreB === null) return 0;
        if (scoreA === null) return -1;
        if (scoreB === null) return 1;

        // Sort based on the order of scores in scoreLabels
        const scoreOrder = Object.keys(scoreLabels);
        return scoreOrder.indexOf(scoreA) - scoreOrder.indexOf(scoreB);
      });
    }

    // Function to display images in a grid with pagination
    function displayImages() {
      const grid = document.getElementById('imageGrid');
      grid.innerHTML = '';

      let imagesToDisplay = images;
      if (paginationEnabled) {
        const startIndex = (currentPage - 1) * imagesPerPage;
        const endIndex = startIndex + imagesPerPage;
        imagesToDisplay = images.slice(startIndex, endIndex);
      }

      imagesToDisplay.forEach((img, index) => {
        const imgContainer = document.createElement('div');
        imgContainer.classList.add('imageItem');

        const imgElement = document.createElement('img');
        imgElement.src = img.data;
        imgElement.dataset.index = index;
        imgElement.style.transform = `rotate(${img.rotation}deg)`;
        imgElement.addEventListener('click', () => {
          const scoreSelector = document.getElementById('scoreSelector');
          if (scoreSelector.value === '') {
            alert('Please select a score.');
            return;
          }
          const score = scoreSelector.value;
          const scoreText = scoreLabels[score];
          const timestamp = new Date().toISOString();
          scores[img.name] = {
            score: score,
            timestamp: timestamp,
            isReplicate: img.isReplicate || false,
            originalName: img.originalName
          };
          imgElement.style.borderColor = scoreColors[score] || 'red';

          // Show score overlay
          if (!imgContainer.querySelector('.scoreOverlay')) {
            const overlay = document.createElement('div');
            overlay.classList.add('scoreOverlay');
            overlay.textContent = 'Score: ' + scoreText;
            imgContainer.appendChild(overlay);
          } else {
            imgContainer.querySelector('.scoreOverlay').textContent = 'Score: ' + scoreText;
          }

          // Re-sort images and re-display
          sortImages();
          displayImages();
        });

        // If image is already scored, show the score
        if (scores[img.name]) {
          const assignedScore = scores[img.name].score;
          imgElement.style.borderColor = scoreColors[assignedScore] || 'red';
          const overlay = document.createElement('div');
          overlay.classList.add('scoreOverlay');
          overlay.textContent = 'Score: ' + scoreLabels[assignedScore];
          imgContainer.appendChild(overlay);
        }

        imgContainer.appendChild(imgElement);
        grid.appendChild(imgContainer);
      });

      updatePaginationControls();
    }

    // Update pagination controls
    function updatePaginationControls() {
      const paginationControls = document.getElementById('paginationControls');
      if (paginationEnabled) {
        paginationControls.style.display = 'block';
        const totalPages = Math.ceil(images.length / imagesPerPage);
        document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages}`;

        document.getElementById('prevPage').disabled = currentPage === 1;
        document.getElementById('nextPage').disabled = currentPage === totalPages;
      } else {
        paginationControls.style.display = 'none';
      }
    }

    // Pagination button event listeners
    document.getElementById('prevPage').addEventListener('click', () => {
      if (currentPage > 1) {
        currentPage--;
        displayImages();
      }
    });

    document.getElementById('nextPage').addEventListener('click', () => {
      const totalPages = Math.ceil(images.length / imagesPerPage);
      if (currentPage < totalPages) {
        currentPage++;
        displayImages();
      }
    });

    // Function to get score label
    function getScoreLabel(score) {
      return scoreLabels[score] || score;
    }

    // Handle score download
    document.getElementById('downloadScores').addEventListener('click', () => {
      // Check for unscored images
      const unscoredImages = images.filter(img => !scores[img.name]);
      if (unscoredImages.length > 0) {
        const proceed = confirm(`There are ${unscoredImages.length} unscored images. Do you want to proceed?`);
        if (!proceed) return;
      }

      // Check consistency in replicated images
      const inconsistencies = checkConsistency();

      if (inconsistencies.length > 0) {
        alert(`There are ${inconsistencies.length} inconsistencies in replicated scores.`);
      }

      // Prepare CSV content
      let csvContent = "File Name,Score,Timestamp,Is Replicate,Original File Name\n";
      images.forEach(img => {
        const data = scores[img.name];
        const score = data ? getScoreLabel(data.score) : '';
        const timestamp = data ? data.timestamp : '';
        const isReplicate = img.isReplicate;
        const originalFileName = img.originalName;
        const fileName = img.name;

        csvContent += `"${fileName}","${score}","${timestamp}","${isReplicate}","${originalFileName}"\n`;
      });

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      saveAs(blob, 'image_scores.csv');
    });

    // Function to check consistency in replicated images
    function checkConsistency() {
      const inconsistencies = [];

      images.forEach(img => {
        if (img.isReplicate) {
          const originalData = scores[img.originalName];
          const replicateData = scores[img.name];

          if (originalData && replicateData && originalData.score !== replicateData.score) {
            inconsistencies.push({
              originalFileName: img.originalName,
              replicateFileName: img.name,
              originalScore: getScoreLabel(originalData.score),
              replicateScore: getScoreLabel(replicateData.score)
            });
          }
        }
      });

      return inconsistencies;
    }
  </script>
</body>
</html>
