<!DOCTYPE html>
<html>
<head>
  <title>Enhanced Image Scoring App</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
    #imageGrid {
      display: flex;
      flex-wrap: wrap;
    }
    .imageItem {
      position: relative;
      margin: 5px;
    }
    .imageItem img {
      width: 150px;
      height: auto;
      border: 3px solid black;
      cursor: pointer;
    }
    .imageItem .scoreOverlay {
      position: absolute;
      bottom: 5px;
      left: 5px;
      background-color: rgba(255, 255, 255, 0.7);
      padding: 2px 5px;
      font-size: 14px;
    }
    #paginationControls {
      margin-top: 10px;
      text-align: center;
    }
    #paginationControls button {
      margin: 0 5px;
    }
    #instructions {
      background-color: #f9f9f9;
      padding: 10px;
      margin-bottom: 20px;
    }
    #instructions h2 {
      margin-top: 0;
    }
    #loadingMessage {
      font-size: 18px;
      color: green;
    }
  </style>
</head>
<body>
  <h1>Enhanced Image Scoring App</h1>

  <div id="instructions">
    <h2>Instructions</h2>
    <ol>
      <li>Upload a ZIP file containing your images.</li>
      <li>Enter custom scores and click "Set Scores" (optional).</li>
      <li>Set a default score if desired.</li>
      <li>Set the replication factor if needed (e.g., 1.2 for 20% replication).</li>
      <li>Choose whether to enable pagination and specify images per page.</li>
      <li>Click "Load Images" to begin.</li>
      <li>Select a score and click on images to assign or change scores.</li>
      <li>Use pagination controls to navigate through images (if enabled).</li>
      <li>Once finished, click "Download Scores" to export the data.</li>
    </ol>
  </div>

  <input type="file" id="zipInput" accept=".zip">
  <br><br>

  <label for="customScores">Enter Custom Scores (comma-separated, optionally with labels using colon):</label>
  <input type="text" id="customScores" placeholder="e.g., 0: Poor,1: Fair,2: Good">
  <button id="setScores">Set Scores</button>
  <br><br>

  <label for="defaultScore">Default Score (optional):</label>
  <input type="text" id="defaultScore" placeholder="Enter default score">
  <br><br>

  <label for="replicationFactor">Replication Factor (e.g., 1.2 for 20% replication):</label>
  <input type="number" id="replicationFactor" value="1.0" min="1.0" step="0.1">
  <br><br>

  <input type="checkbox" id="enablePagination">
  <label for="enablePagination">Enable Pagination</label>
  <br><br>

  <div id="paginationSettings" style="display: none;">
    <label for="imagesPerPage">Images Per Page:</label>
    <input type="number" id="imagesPerPage" value="20" min="1" step="1">
    <br><br>
  </div>

  <button id="loadImages">Load Images</button>
  <br><br>

  <label for="scoreSelector">Select Score:</label>
  <select id="scoreSelector"></select>
  <button id="downloadScores">Download Scores</button>
  <br><br>

  <div id="paginationControls" style="display: none;">
    <button id="prevPage">Previous</button>
    <span id="pageInfo"></span>
    <button id="nextPage">Next</button>
  </div>

  <div id="loadingMessage"></div>
  <hr>
  <div id="imageGrid"></div>

  <!-- Include JSZip and FileSaver.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

  <!-- Main JavaScript code -->
  <script>
    // Variables to store images and scores
    let images = [];
    let scores = {};
    let scoreLabels = {};
    let currentPage = 1;
    let imagesPerPage = 20;
    let paginationEnabled = false;
    let scoreColors = {}; // To store colors for each score

    // Handle zip file upload
    document.getElementById('zipInput').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file) {
        document.getElementById('loadingMessage').textContent = 'Unzipping and processing images...';
      }
    });

    // Event listener for setting custom scores
    document.getElementById('setScores').addEventListener('click', () => {
      const customScoresInput = document.getElementById('customScores').value;
      const customScoresArray = parseCustomScores(customScoresInput);

      if (customScoresArray.length > 0) {
        populateScoreSelector(customScoresArray);
        assignScoreColors(customScoresArray);
      } else {
        alert('Please enter valid scores.');
      }
    });

    // Show or hide pagination settings
    document.getElementById('enablePagination').addEventListener('change', function() {
      const paginationSettings = document.getElementById('paginationSettings');
      if (this.checked) {
        paginationSettings.style.display = 'block';
      } else {
        paginationSettings.style.display = 'none';
      }
    });

    // Event listener for loading images
    document.getElementById('loadImages').addEventListener('click', async () => {
      const fileInput = document.getElementById('zipInput');
      const file = fileInput.files[0];
      if (!file) {
        alert('Please upload a zip file containing images.');
        return;
      }

      document.getElementById('loadingMessage').textContent = 'Unzipping and processing images...';

      const zip = await JSZip.loadAsync(file);
      images = []; // Reset images array
      scores = {}; // Reset scores

      for (const relativePath in zip.files) {
        const zipEntry = zip.files[relativePath];
        if (!zipEntry.dir && /\.(png|jpg|jpeg)$/i.test(zipEntry.name)) {
          const imgData = await zipEntry.async('base64');
          images.push({
            name: zipEntry.name,
            data: 'data:image/jpeg;base64,' + imgData,
            anonymousId: '', // To be assigned later
            isReplicate: false,
            originalName: zipEntry.name
          });
        }
      }

      if (images.length === 0) {
        alert('No valid images found in the zip file.');
        document.getElementById('loadingMessage').textContent = '';
        return;
      }

      // Assign anonymous IDs
      images.forEach((img, index) => {
        img.anonymousId = 'Image_' + (index + 1);
      });

      // Replicate images if needed
      const replicationFactor = parseFloat(document.getElementById('replicationFactor').value) || 1.0;
      images = replicateImages(images, replicationFactor);

      // Shuffle images
      shuffleArray(images);

      // Pagination settings
      paginationEnabled = document.getElementById('enablePagination').checked;
      imagesPerPage = parseInt(document.getElementById('imagesPerPage').value) || 20;
      currentPage = 1;

      // Assign default score if set
      const defaultScore = document.getElementById('defaultScore').value;
      if (defaultScore !== '' && scoreLabels[defaultScore]) {
        images.forEach(img => {
          const timestamp = new Date().toISOString();
          scores[img.name] = {
            score: defaultScore,
            timestamp: timestamp,
            isReplicate: img.isReplicate || false,
            originalName: img.originalName,
            anonymousId: img.anonymousId
          };
        });
      }

      // Display images
      displayImages();

      document.getElementById('loadingMessage').textContent = '';
    });

    // Function to parse custom scores input
    function parseCustomScores(input) {
      const scores = input.split(',').map(s => s.trim()).filter(s => s !== '');
      const uniqueScores = [];
      scoreLabels = {};

      scores.forEach(s => {
        const [score, label] = s.split(':').map(part => part.trim());
        if (score && !uniqueScores.includes(score)) {
          uniqueScores.push(score);
          scoreLabels[score] = label || score; // Use label if provided, else use score as label
        }
      });

      return uniqueScores;
    }

    // Function to assign colors to scores
    function assignScoreColors(scoresArray) {
      const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray', 'teal', 'magenta'];
      scoreColors = {};
      scoresArray.forEach((score, index) => {
        scoreColors[score] = colors[index % colors.length];
      });
    }

    // Function to populate the score selector
    function populateScoreSelector(scoresArray) {
      const scoreSelector = document.getElementById('scoreSelector');
      scoreSelector.innerHTML = ''; // Clear existing options
      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = '-- Select Score --';
      scoreSelector.appendChild(defaultOption);

      scoresArray.forEach(score => {
        const option = document.createElement('option');
        option.value = score;
        option.textContent = scoreLabels[score];
        scoreSelector.appendChild(option);
      });
    }

    // Function to replicate images
    function replicateImages(imagesArray, replicationFactor) {
      const numOriginalImages = imagesArray.length;
      const numReplicates = Math.round((replicationFactor - 1) * numOriginalImages);

      const replicatedImages = [];
      for (let i = 0; i < numReplicates; i++) {
        const randomIndex = Math.floor(Math.random() * numOriginalImages);
        const originalImage = imagesArray[randomIndex];

        // Create a copy of the image object
        const replicatedImage = {
          ...originalImage,
          isReplicate: true,
          originalName: originalImage.name
        };

        replicatedImages.push(replicatedImage);
      }

      // Combine original and replicated images
      return imagesArray.concat(replicatedImages);
    }

    // Function to shuffle an array
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Function to display images in a grid with pagination
    function displayImages() {
      const grid = document.getElementById('imageGrid');
      grid.innerHTML = '';

      let imagesToDisplay = images;
      if (paginationEnabled) {
        const startIndex = (currentPage - 1) * imagesPerPage;
        const endIndex = startIndex + imagesPerPage;
        imagesToDisplay = images.slice(startIndex, endIndex);
      }

      imagesToDisplay.forEach((img, index) => {
        const imgContainer = document.createElement('div');
        imgContainer.classList.add('imageItem');

        const imgElement = document.createElement('img');
        imgElement.src = img.data;
        imgElement.dataset.index = index;
        imgElement.addEventListener('click', () => {
          let score;
          let timestamp = new Date().toISOString();

          const scoreSelector = document.getElementById('scoreSelector');
          if (scoreSelector.value !== '') {
            score = scoreSelector.value;
          } else if (scores[img.name]) {
            score = scores[img.name].score;
          } else {
            alert('Please select a score.');
            return;
          }

          const scoreText = scoreLabels[score];
          scores[img.name] = {
            score: score,
            timestamp: timestamp,
            isReplicate: img.isReplicate || false,
            originalName: img.originalName,
            anonymousId: img.anonymousId
          };
          imgElement.style.borderColor = scoreColors[score] || 'red';

          // Show score overlay
          if (!imgContainer.querySelector('.scoreOverlay')) {
            const overlay = document.createElement('div');
            overlay.classList.add('scoreOverlay');
            overlay.textContent = 'Score: ' + scoreText;
            imgContainer.appendChild(overlay);
          } else {
            imgContainer.querySelector('.scoreOverlay').textContent = 'Score: ' + scoreText;
          }
        });

        // If image is already scored, show the score
        if (scores[img.name]) {
          const assignedScore = scores[img.name].score;
          imgElement.style.borderColor = scoreColors[assignedScore] || 'red';
          const overlay = document.createElement('div');
          overlay.classList.add('scoreOverlay');
          overlay.textContent = 'Score: ' + scoreLabels[assignedScore];
          imgContainer.appendChild(overlay);
        }

        imgContainer.appendChild(imgElement);
        grid.appendChild(imgContainer);
      });

      updatePaginationControls();
    }

    // Update pagination controls
    function updatePaginationControls() {
      const paginationControls = document.getElementById('paginationControls');
      if (paginationEnabled) {
        paginationControls.style.display = 'block';
        const totalPages = Math.ceil(images.length / imagesPerPage);
        document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages}`;

        document.getElementById('prevPage').disabled = currentPage === 1;
        document.getElementById('nextPage').disabled = currentPage === totalPages;
      } else {
        paginationControls.style.display = 'none';
      }
    }

    // Pagination button event listeners
    document.getElementById('prevPage').addEventListener('click', () => {
      if (currentPage > 1) {
        currentPage--;
        displayImages();
      }
    });

    document.getElementById('nextPage').addEventListener('click', () => {
      const totalPages = Math.ceil(images.length / imagesPerPage);
      if (currentPage < totalPages) {
        currentPage++;
        displayImages();
      }
    });

    // Function to get score label
    function getScoreLabel(score) {
      return scoreLabels[score] || score;
    }

    // Handle score download
    document.getElementById('downloadScores').addEventListener('click', () => {
      // Check for unscored images
      const unscoredImages = images.filter(img => !scores[img.name]);
      if (unscoredImages.length > 0) {
        const proceed = confirm(`There are ${unscoredImages.length} unscored images. Do you want to proceed?`);
        if (!proceed) return;
      }

      // Check consistency in replicated images
      const inconsistencies = checkConsistency();

      if (inconsistencies.length > 0) {
        alert(`There are ${inconsistencies.length} inconsistencies in replicated scores.`);
      }

      // Prepare CSV content
      let csvContent = "Image ID,File Name,Score,Timestamp,Is Replicate,Original Image ID\n";
      images.forEach(img => {
        const data = scores[img.name];
        const score = data ? getScoreLabel(data.score) : '';
        const timestamp = data ? data.timestamp : '';
        const isReplicate = data ? data.isReplicate : false;
        const originalAnonymousId = data ? images.find(image => image.name === data.originalName).anonymousId : img.anonymousId;
        const fileName = img.name;

        csvContent += `"${img.anonymousId}","${fileName}","${score}","${timestamp}","${isReplicate}","${originalAnonymousId}"\n`;
      });

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      saveAs(blob, 'image_scores.csv');
    });

    // Function to check consistency in replicated images
    function checkConsistency() {
      const inconsistencies = [];

      images.forEach(img => {
        if (img.isReplicate) {
          const originalData = scores[img.originalName];
          const replicateData = scores[img.name];

          if (originalData && replicateData && originalData.score !== replicateData.score) {
            inconsistencies.push({
              originalAnonymousId: images.find(image => image.name === img.originalName).anonymousId,
              replicateAnonymousId: img.anonymousId,
              originalScore: getScoreLabel(originalData.score),
              replicateScore: getScoreLabel(replicateData.score)
            });
          }
        }
      });

      return inconsistencies;
    }
  </script>
</body>
</html>
